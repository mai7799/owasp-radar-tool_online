import { updateEChartsChartTitle } from './chart-common.js';

// --- 模組內全域變數 ---
const echartsCategories_VulnMap = [
    { id: 'A01', name: 'A01: 權限控制失效', short: 'A01' }, { id: 'A02', name: 'A02: 加密機制失效', short: 'A02' },
    { id: 'A03', name: 'A03: 注入式攻擊', short: 'A03' }, { id: 'A04', name: 'A04: 不安全設計', short: 'A04' },
    { id: 'A05', name: 'A05: 安全設定弱點', short: 'A05' }, { id: 'A06', name: 'A06: 危險或過舊的元件', short: 'A06' },
    { id: 'A07', name: 'A07: 認證及驗證機制失效', short: 'A07' }, { id: 'A08', name: 'A08: 軟體及資料完整性失效', short: 'A08' },
    { id: 'A09', name: 'A09: 資安記錄及監控失效', short: 'A09' }, { id: 'A10', name: 'A10: 伺服端請求偽造', short: 'A10' }
];
let vulnerabilitiesForVulnMap = [];
let echartsRadarInstance = null;

// --- 函式定義 (來自您的原始碼) ---

function populateVulnCategoryDropdown() {
    const categorySelect = document.getElementById('vulnCategoryInMap');
    if (categorySelect) {
        categorySelect.innerHTML = '';
        echartsCategories_VulnMap.forEach((cat, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = cat.name;
            categorySelect.appendChild(option);
        });
    }
}

function removeVulnFromMap(index) {
    vulnerabilitiesForVulnMap.splice(index, 1);
    updateVulnTableInMapTab();
    renderEchartsForVulnMapTab();
}

function updateVulnTableInMapTab() {
    const listElement = document.getElementById('vulnerabilityListInMap');
    if (!listElement) { return; }
    listElement.innerHTML = '';
    vulnerabilitiesForVulnMap.forEach((vuln, index) => {
        const listItem = document.createElement('li');
        listItem.textContent = `名稱: ${vuln.name}, 類別: ${echartsCategories_VulnMap[vuln.categoryIndex].short}, CVE: ${vuln.severity}`;
        const deleteButton = document.createElement('button');
        deleteButton.textContent = '刪除';
        deleteButton.classList.add('delete-btn');
        deleteButton.addEventListener('click', () => removeVulnFromMap(index));
        listItem.appendChild(deleteButton);
        listElement.appendChild(listItem);
    });
}

function renderEchartsForVulnMapTab() {
    if (!echartsRadarInstance) return;
    const echartsData = [];
    const groupedForDispersion = {};
    vulnerabilitiesForVulnMap.forEach(vuln => {
        const key = `${vuln.categoryIndex}_${vuln.severity}`;
        if (!groupedForDispersion[key]) { groupedForDispersion[key] = []; }
        groupedForDispersion[key].push(vuln);
    });

    for (const key in groupedForDispersion) {
        const group = groupedForDispersion[key];
        const [categoryIndexStr, severityStr] = key.split('_');
        const categoryIndex = parseInt(categoryIndexStr);
        const severity = parseFloat(severityStr);
        const countInGroup = group.length;
        const radiusValue = severity;
        const categoryAngleStep = 360 / echartsCategories_VulnMap.length;
        const categoryStartAngle = categoryIndex * categoryAngleStep;
        const spreadAngularWidth = categoryAngleStep * 0.7;
        const angleOffsetWithinSlice = (categoryAngleStep - spreadAngularWidth) / 2;

        group.forEach((vulnItem, indexInGroup) => {
            let pointSpecificAngleOffset;
            if (countInGroup === 1) { pointSpecificAngleOffset = spreadAngularWidth / 2; }
            else { pointSpecificAngleOffset = (indexInGroup / (countInGroup - 1)) * spreadAngularWidth; }
            const finalAngle = categoryStartAngle + angleOffsetWithinSlice + pointSpecificAngleOffset;
            let pointColor;
            if (severity >= 9) pointColor = '#ff0000'; else if (severity >= 7) pointColor = '#ff6b33';
            else if (severity >= 4) pointColor = '#ffcc00'; else pointColor = '#66cc66';
            echartsData.push({
                vulnName: vulnItem.name, categoryName: echartsCategories_VulnMap[vulnItem.categoryIndex].name,
                severityScore: vulnItem.severity, value: [radiusValue, finalAngle], itemStyle: { color: pointColor }
            });
        });
    }
    echartsRadarInstance.setOption({ series: [{ data: echartsData }] });
}


function addVulnToMap() {
    const name = document.getElementById('vulnNameInMap').value.trim();
    const categoryIndex = parseInt(document.getElementById('vulnCategoryInMap').value);
    const severity = parseFloat(document.getElementById('vulnSeverityInMap').value);

    if (!name) { alert('請輸入弱點名稱。'); return; }
    if (isNaN(categoryIndex)) { alert('請選擇有效的OWASP類別。'); return; }
    if (isNaN(severity) || severity < 1 || severity > 10) { alert('CVE必須是 1 到 10 之間的數字。'); return; }

    vulnerabilitiesForVulnMap.push({ name: name, categoryIndex: categoryIndex, severity: severity });
    document.getElementById('vulnNameInMap').value = '';
    document.getElementById('vulnSeverityInMap').value = '5';
    updateVulnTableInMapTab();
    renderEchartsForVulnMapTab();
}

function resetVulnMap() {
    vulnerabilitiesForVulnMap = [];
    document.getElementById('vulnNameInMap').value = '';
    document.getElementById('vulnSeverityInMap').value = 5;
    document.getElementById('vulnCategoryInMap').value = '0'; // Reset to the first option
    updateVulnTableInMapTab();
    renderEchartsForVulnMapTab();
}

function downloadVulnMapImage() {
    if (echartsRadarInstance) {
        const imageUrl = echartsRadarInstance.getDataURL({ type: 'png', pixelRatio: 2, backgroundColor: '#fff' });
        const date = new Date(); const dateStr = date.toISOString().replace(/[:.]/g, '-').substring(0, 19);
        saveAs(imageUrl, `owasp_vuln_map_${dateStr}.png`);
    } else { alert('ECharts 圖表尚未初始化。'); }
}

function parseWordForVulnMap() {
    const fileInput = document.getElementById('vulnMapWordFile');
    if (!fileInput.files.length) { alert('請先選擇 Word 檔案'); return; }
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function (event) {
        const arrayBuffer = event.target.result;
        Promise.all([
            mammoth.convertToHtml({ arrayBuffer }),
            mammoth.extractRawText({ arrayBuffer })
        ]).then(([htmlResult, rawTextResult]) => {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlResult.value;
            const tables = tempDiv.querySelectorAll('table');
            let vulnerabilities = [];
            let vulnListTable = null;
            for (let table of tables) {
                const headers = Array.from(table.querySelectorAll('tr:first-child td')).map(td => td.innerText.trim());
                if (headers.includes('漏洞名稱') && headers.includes('OWASP Top 10')) {
                    vulnListTable = table;
                    break;
                }
            }
            if (!vulnListTable) { alert('在文件中找不到符合格式的 "受測目標風險漏洞名稱列表" 表格。'); return; }
            const rows = vulnListTable.querySelectorAll('tr');
            rows.forEach((row, rowIndex) => {
                if (rowIndex === 0) return;
                const cells = row.querySelectorAll('td');
                let vulnName = '';
                let owaspText = '';
                if (cells.length === 7) {
                    vulnName = cells[2].innerText.trim();
                    owaspText = cells[6].innerText.trim();
                } else if (cells.length === 6) {
                    vulnName = cells[1].innerText.trim();
                    owaspText = cells[5].innerText.trim();
                }
                const owaspMatch = owaspText ? owaspText.match(/A\d{2}/) : null;
                if (vulnName && owaspMatch) {
                    vulnerabilities.push({ name: vulnName, owaspId: owaspMatch[0], severity: 0 });
                }
            });
            const rawText = rawTextResult.value;
            const analysisStartIndex = rawText.indexOf("弱點分析與測試說明");
            const analysisText = analysisStartIndex !== -1 ? rawText.substring(analysisStartIndex) : "";
            const detailChunks = analysisText.split(/(?:嚴重|高|中|低)風險 - /).slice(1);
            vulnerabilities.forEach(vuln => {
                const correctChunk = detailChunks.find(chunk => chunk.trim().startsWith(vuln.name));
                if (correctChunk) {
                    const scoreMatch = correctChunk.match(/CVSSv4 Score：(\d{1,2}\.\d)/);
                    if (scoreMatch && scoreMatch[1]) {
                        vuln.severity = parseFloat(scoreMatch[1]);
                    } else { console.warn(`在 "${vuln.name}" 的區塊中找不到CVSS分數。`); }
                } else { console.warn(`找不到 "${vuln.name}" 的詳細說明區塊。`); }
            });
            vulnerabilitiesForVulnMap = [];
            vulnerabilities.forEach(vuln => {
                if (vuln.severity > 0) {
                    const categoryIndex = echartsCategories_VulnMap.findIndex(cat => cat.id === vuln.owaspId);
                    if (categoryIndex !== -1) {
                        vulnerabilitiesForVulnMap.push({ name: vuln.name, categoryIndex: categoryIndex, severity: vuln.severity });
                    }
                }
            });
            updateVulnTableInMapTab();
            renderEchartsForVulnMapTab();
            alert(`成功解析並載入 ${vulnerabilitiesForVulnMap.length} 個弱點！`);
        }).catch(function (error) {
            alert('解析Word檔案失敗: ' + error.message);
            console.error(error);
        });
    };
    reader.readAsArrayBuffer(file);
}

function initEchartsForVulnMapTab() {
    const chartDom = document.getElementById('owaspRadarChart');
    if (!chartDom) { console.error("#owaspRadarChart div not found for ECharts."); return; }
    echartsRadarInstance = echarts.init(chartDom);
    window.echartsRadarInstance = echartsRadarInstance; // 掛載到 window 供 main.js 使用
    const option = {
        title: { text: document.getElementById('vulnerabilityMapChartTitle').value || '弱點分布雷達圖', left: 'center', top: 10, bottom: 5 },
        polar: { center: ['55%', '53%'], radius: '75%' },
        tooltip: {
            trigger: 'item',
            formatter: function (params) {
                if (params.data && params.data.vulnName) {
                    return `<b>${params.data.vulnName}</b><br/>類別: ${params.data.categoryName}<br/>CVE: ${params.data.severityScore}`;
                } return '';
            }
        },
        angleAxis: {
            type: 'value', min: 0, max: 360,
            interval: 360 / echartsCategories_VulnMap.length,
            axisLabel: {
                formatter: function (value) {
                    const index = Math.round(value / (360 / echartsCategories_VulnMap.length)) % echartsCategories_VulnMap.length;
                    return echartsCategories_VulnMap[index] ? echartsCategories_VulnMap[index].name : '';
                }, fontSize: 14, margin: 15, color: '#666'
            },
            axisLine: { lineStyle: { color: '#aaa' } },
            splitLine: { show: true, lineStyle: { color: '#ddd', type: 'dashed' } }
        },
        radiusAxis: {
            type: 'value', min: 0, max: 10, interval: 1,
            axisLabel: {
                formatter: function (value) {
                    if (value >= 0 && value <= 10) return String(value); return '';
                }, fontSize: 12, color: '#666'
            },
            splitLine: { lineStyle: { color: '#ddd', type: 'dashed' } },
            axisLine: { lineStyle: { color: '#aaa' } }
        },
        series: [{
            name: 'Vulnerabilities', type: 'scatter', coordinateSystem: 'polar', symbolSize: 8,
            label: {
                show: true, position: 'right', fontSize: 9, color: '#555',
                formatter: function (params) { return params.data.vulnName; }
            },
            labelLayout: { draggable: true, moveOverlap: 'shiftY' },
            emphasis: { focus: 'series', scale: 1.2 },
            data: []
        }]
    };
    echartsRadarInstance.setOption(option);
}

// --- 初始化函式 (模組入口) ---
export function init() {
    // 初始化 UI 和圖表
    populateVulnCategoryDropdown();
    initEchartsForVulnMapTab();
    updateVulnTableInMapTab();

    // 綁定所有事件
    document.getElementById('addVulnToMapBtn').addEventListener('click', addVulnToMap);
    document.getElementById('resetVulnMapBtn').addEventListener('click', resetVulnMap);
    document.getElementById('updateVulnMapTitleBtn').addEventListener('click', () => updateEChartsChartTitle(echartsRadarInstance, 'vulnerabilityMapChartTitle'));
    document.getElementById('downloadVulnMapImageBtn').addEventListener('click', downloadVulnMapImage);
    
    const wordFileInput = document.getElementById('vulnMapWordFile');
    document.getElementById('parseVulnMapWordBtn').addEventListener('click', () => wordFileInput.click());
    wordFileInput.addEventListener('change', parseWordForVulnMap);
}